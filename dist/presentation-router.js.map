{"version":3,"sources":["webpack://presentation-router/webpack/universalModuleDefinition","webpack://presentation-router/webpack/bootstrap","webpack://presentation-router/external {\"commonjs\":\"augmentedjs-next\",\"commonjs2\":\"augmentedjs-next\",\"amd\":\"augmentedjs-next\",\"root\":\"Augmented\"}","webpack://presentation-router/./src/history.js","webpack://presentation-router/./src/index.js","webpack://presentation-router/./src/router.js","webpack://presentation-router/external {\"commonjs\":\"presentation-dom\",\"commonjs2\":\"presentation-dom\",\"amd\":\"presentation-dom\",\"root\":\"presentation-dom\"}","webpack://presentation-router/external {\"commonjs\":\"lodash.map\",\"commonjs2\":\"lodash.map\",\"amd\":\"lodash.map\",\"root\":\"lodash.map\"}","webpack://presentation-router/external {\"commonjs\":\"lodash.isregexp\",\"commonjs2\":\"lodash.isregexp\",\"amd\":\"lodash.isregexp\",\"root\":\"lodash.isregexp\"}","webpack://presentation-router/./src/serialize.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__4__","__WEBPACK_EXTERNAL_MODULE__5__","__WEBPACK_EXTERNAL_MODULE__6__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Augmented","ROUTE_STRIPPER","ROOT_STRIPPER","PATH_STRIPPER","constructor","super","options","handlers","checkUrl","window","location","history","interval","started","atRoot","pathname","replace","path","getSearch","matchRoot","decodeFragment","length","decodeURI","fragment","match","href","getHash","getPath","slice","getFragment","_usePushState","_wantsHashChange","start","Error","hashChange","_hasHashChange","document","_useHashChange","_wantsPushState","pushState","_hasPushState","rootPath","navigate","iframe","src","style","display","tabIndex","body","iWindow","contentWindow","addEventListener","eventName","listener","attachEvent","_checkUrlInterval","setInterval","silent","loadUrl","stop","removeEventListener","detachEvent","clearInterval","route","unshift","callback","current","Array","some","handler","trigger","url","title","assign","_updateHash","Router","History","serialize","_map","_isRegExp","optionalParam","namedParam","splatParam","escapeRegExp","routes","transition","default","_bindRoutes","initialize","[object Object]","queryString","query","pairs","split","pair","decodeURIComponent","view","_view","loadView","in","el","renderView","Dom","render","delegateEvents","Promise","cleanup","out","cleanupView","console","remove","_routeToRegExp","router","args","concat","execute","startHistory","pop","optional","RegExp","_extractParameters","params","param","obj","str","encodeURIComponent"],"mappings":"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","file":"presentation-router.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"augmentedjs-next\"), require(\"presentation-dom\"), require(\"lodash.map\"), require(\"lodash.isregexp\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"presentation-router\", [\"augmentedjs-next\", \"presentation-dom\", \"lodash.map\", \"lodash.isregexp\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"presentation-router\"] = factory(require(\"augmentedjs-next\"), require(\"presentation-dom\"), require(\"lodash.map\"), require(\"lodash.isregexp\"));\n\telse\n\t\troot[\"presentation-router\"] = factory(root[\"Augmented\"], root[\"presentation-dom\"], root[\"lodash.map\"], root[\"lodash.isregexp\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__4__, __WEBPACK_EXTERNAL_MODULE__5__, __WEBPACK_EXTERNAL_MODULE__6__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import * as Augmented from \"augmentedjs-next\";\n\n//const _some = require(\"lodash.some\");\n\n// Cached regex for stripping a leading hash/slash and trailing space.\nconst ROUTE_STRIPPER = /^[#\\/]|\\s+$/g;\n\n// Cached regex for stripping leading and trailing slashes.\nconst ROOT_STRIPPER = /^\\/+|\\/+$/g;\n\n// Cached regex for stripping urls of hash.\nconst PATH_STRIPPER = /#.*$/;\n\n/**\n * Handles cross-browser history management, based on either\n * [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n * [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n * and URL fragments. If the browser supports neither (old IE, natch),\n * falls back to polling.\n * <br/>Inspired By Backbone.js - Thank you! <span>😍</span>\n * @extends Augmented.Object\n */\nclass History extends Augmented.Object {\n  constructor(options) {\n    super(options);\n    this.handlers = [];\n    this.checkUrl = this.checkUrl.bind(this);\n\n    // Ensure that `History` can be used outside of the browser.\n    if (typeof window !== 'undefined') {\n      this.location = window.location;\n      this.history = window.history;\n    }\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    this.interval = 50;\n\n    // Has the history handling already been started?\n    this.started = false;\n  };\n\n  // Are we at the app root?\n  atRoot() {\n    let path = this.location.pathname.replace(/[^\\/]$/, '$&/');\n    return path === this.root && !this.getSearch();\n  };\n\n  // Does the pathname match the root?\n  matchRoot() {\n    const path = this.decodeFragment(this.location.pathname);\n    const rootPath = path.slice(0, this.root.length - 1) + '/';\n    //console.log(`History: matchRoot ${rootPath} and root is ${this.root}`);\n    return rootPath === this.root;\n  };\n\n  // Unicode characters in `location.pathname` are percent encoded so they're\n  // decoded for comparison. `%25` should not be decoded since it may be part\n  // of an encoded parameter.\n  decodeFragment(fragment) {\n    return decodeURI(fragment.replace(/%25/g, '%2525'));\n  };\n\n  // In IE6, the hash fragment and search params are incorrect if the\n  // fragment contains `?`.\n  getSearch() {\n    const match = this.location.href.replace(/#.*/, '').match(/\\?.+/);\n    return match ? match[0] : '';\n  };\n\n  // Gets the true hash value. Cannot use location.hash directly due to bug\n  // in Firefox where location.hash will always be decoded.\n  getHash(window) {\n    const match = (window || this).location.href.match(/#(.*)$/);\n    return match ? match[1] : '';\n  };\n\n  // Get the pathname and search params, without the root.\n  getPath() {\n    const path = this.decodeFragment(\n      this.location.pathname + this.getSearch()\n    ).slice(this.root.length - 1);\n    return path.charAt(0) === '/' ? path.slice(1) : path;\n  };\n\n  // Get the cross-browser normalized URL fragment from the path or hash.\n  getFragment(fragment) {\n    if (fragment == null) {\n      if (this._usePushState || !this._wantsHashChange) {\n        fragment = this.getPath();\n      } else {\n        fragment = this.getHash();\n      }\n    }\n    return fragment.replace(ROUTE_STRIPPER, '');\n  };\n\n  // Start the hash change handling, returning `true` if the current URL matches\n  // an existing route, and `false` otherwise.\n  start(options) {\n    if (this.started) {\n      throw new Error('History has already been started');\n    }\n    this.started = true;\n\n    // Figure out the initial configuration. Do we need an iframe?\n    // Is pushState desired ... is it available?\n    this.options          = Augmented.Utility.extend({root: '/'}, this.options, options);\n    this.root             = this.options.root;\n    this._wantsHashChange = this.options.hashChange !== false;\n    this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);\n    this._useHashChange   = this._wantsHashChange && this._hasHashChange;\n    this._wantsPushState  = !!this.options.pushState;\n    this._hasPushState    = !!(this.history && this.history.pushState);\n    this._usePushState    = this._wantsPushState && this._hasPushState;\n    this.fragment         = this.getFragment();\n\n    // Normalize root to always include a leading and trailing slash.\n    this.root = (`/${this.root}/`).replace(ROOT_STRIPPER, '/');\n\n    // Transition from hashChange to pushState or vice versa if both are\n    // requested.\n    if (this._wantsHashChange && this._wantsPushState) {\n\n      // If we've started off with a route from a `pushState`-enabled\n      // browser, but we're currently in a browser that doesn't support it...\n      if (!this._hasPushState && !this.atRoot()) {\n        const rootPath = this.root.slice(0, -1) || \"/\";\n        this.location.replace(`${rootPath}#${this.getPath()}`);\n        // Return immediately as browser will do redirect to new url\n        return true;\n\n      // Or if we've started out with a hash-based route, but we're currently\n      // in a browser where it could be `pushState`-based instead...\n      } else if (this._hasPushState && this.atRoot()) {\n        this.navigate(this.getHash(), {replace: true});\n      }\n    }\n\n    // Proxy an iframe to handle location events if the browser doesn't\n    // support the `hashchange` event, HTML5 history, or the user wants\n    // `hashChange` but not `pushState`.\n    if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {\n      this.iframe = document.createElement('iframe');\n      this.iframe.src = 'javascript:0';\n      this.iframe.style.display = 'none';\n      this.iframe.tabIndex = -1;\n      const body = document.body;\n      // Using `appendChild` will throw on IE < 9 if the document is not ready.\n      const iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;\n      iWindow.document.open();\n      iWindow.document.close();\n      iWindow.location.hash = '#' + this.fragment;\n    }\n\n    const poly = (eventName, listener) => {\n      return attachEvent('on' + eventName, listener);\n    };\n\n    // Add a cross-platform `addEventListener` shim for older browsers.\n    const addEventListener = (window.addEventListener) ? window.addEventListener : poly;\n\n    // Depending on whether we're using pushState or hashes, and whether\n    // 'onhashchange' is supported, determine how we check the URL state.\n    if (this._usePushState) {\n      addEventListener('popstate', this.checkUrl, false);\n    } else if (this._useHashChange && !this.iframe) {\n      addEventListener('hashchange', this.checkUrl, false);\n    } else if (this._wantsHashChange) {\n      this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n    }\n\n    if (!this.options.silent) {\n      return this.loadUrl();\n    }\n  };\n\n  // Disable history, perhaps temporarily. Not useful in a real app,\n  // but possibly useful for unit testing Routers.\n  stop() {\n    const poly = (eventName, listener) => {\n      return detachEvent('on' + eventName, listener);\n    };\n\n    // Add a cross-platform `removeEventListener` shim for older browsers.\n    const removeEventListener = (window.removeEventListener) ?  window.removeEventListener : poly;\n\n    // Remove window listeners.\n    if (this._usePushState) {\n      removeEventListener('popstate', this.checkUrl, false);\n    } else if (this._useHashChange && !this.iframe) {\n      removeEventListener('hashchange', this.checkUrl, false);\n    }\n\n    // Clean up the iframe if necessary.\n    if (this.iframe) {\n      document.body.removeChild(this.iframe);\n      this.iframe = null;\n    }\n\n    // Some environments will throw when clearing an undefined interval.\n    if (this._checkUrlInterval) {\n      clearInterval(this._checkUrlInterval);\n    }\n    this.started = false;\n  };\n\n  // Add a route to be tested when the fragment changes. Routes added later\n  // may override previous routes.\n  route(route, callback) {\n    this.handlers.unshift({route: route, callback: callback});\n  };\n\n  // Checks the current URL to see if it has changed, and if it has,\n  // calls `loadUrl`, normalizing across the hidden iframe.\n  checkUrl(e) {\n    let current = this.getFragment();\n\n    // If the user pressed the back button, the iframe's hash will have\n    // changed and we should use that for comparison.\n    if (current === this.fragment && this.iframe) {\n      current = this.getHash(this.iframe.contentWindow);\n    }\n\n    if (current === this.fragment) {\n      return false;\n    }\n    if (this.iframe) this.navigate(current);\n    this.loadUrl();\n  };\n\n  // Attempt to load the current URL fragment. If a route succeeds with a\n  // match, returns `true`. If no defined routes matches the fragment,\n  // returns `false`.\n  loadUrl(fragment) {\n    // If the root doesn't match, no routes can match either.\n    if (!this.matchRoot()) {\n      return false;\n    }\n    fragment = this.fragment = this.getFragment(fragment);\n    //console.log(\"loadUrl\", fragment);\n    //console.log(\"this.handlers\", this.handlers);\n    if (this.handlers && Array.isArray(this.handlers)) {\n      return this.handlers.some((handler) => {\n        //console.log(\"handler\", handler);\n        if (handler.route.test(fragment)) {\n          //console.log(\"handler.callback\", handler.callback);\n          //console.log(\"is func\", typeof handler.callback);\n          handler.callback(fragment);\n          //console.log(\"test\", handler.route.test(fragment));\n          return true;\n        }\n      });\n    }\n    return null;\n\n    /*return _some(this.handlers, (handler) => {\n      if (handler.route.test(fragment)) {\n        handler.callback(fragment);\n        return true;\n      }\n    });*/\n  };\n\n  // Save a fragment into the hash history, or replace the URL state if the\n  // 'replace' option is passed. You are responsible for properly URL-encoding\n  // the fragment in advance.\n  //\n  // The options object can contain `trigger: true` if you wish to have the\n  // route callback be fired (not usually desirable), or `replace: true`, if\n  // you wish to modify the current URL without adding an entry to the history.\n  navigate(fragment, options) {\n    if (!this.started) {\n      return false;\n    }\n    if (!options || options === true) {\n      options = {trigger: !!options};\n    }\n\n    // Normalize the fragment.\n    fragment = this.getFragment(fragment || '');\n\n    // Don't include a trailing slash on the root.\n    let rootPath = this.root;\n    if (fragment === '' || fragment.charAt(0) === '?') {\n      rootPath = rootPath.slice(0, -1) || '/';\n    }\n    const url = rootPath + fragment;\n\n    // Strip the hash and decode for matching.\n    fragment = this.decodeFragment(fragment.replace(PATH_STRIPPER, ''));\n\n    if (this.fragment === fragment) {\n      return;\n    }\n    this.fragment = fragment;\n\n    // If pushState is available, we use it to set the fragment as a real URL.\n    if (this._usePushState) {\n      this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n    // If hash changes haven't been explicitly disabled, update the hash\n    // fragment to store history.\n    } else if (this._wantsHashChange) {\n      this._updateHash(this.location, fragment, options.replace);\n      if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {\n        const iWindow = this.iframe.contentWindow;\n\n        // Opening and closing the iframe tricks IE7 and earlier to push a\n        // history entry on hash-tag change.  When replace is true, we don't\n        // want this.\n        if (!options.replace) {\n          iWindow.document.open();\n          iWindow.document.close();\n        }\n\n        this._updateHash(iWindow.location, fragment, options.replace);\n      }\n\n    // If you've told us that you explicitly don't want fallback hashchange-\n    // based history, then `navigate` becomes a page refresh.\n    } else {\n      return this.location.assign(url);\n    }\n    if (options.trigger) {\n      return this.loadUrl(fragment);\n    }\n  };\n\n  // Update the hash location, either replacing the current entry, or adding\n  // a new one to the browser history.\n  _updateHash(location, fragment, replace) {\n    if (replace) {\n      const href = location.href.replace(/(javascript:|#).*$/, '');\n      location.replace(href + '#' + fragment);\n    } else {\n      // Some browsers require that `hash` contains a leading #.\n      location.hash = '#' + fragment;\n    }\n  }\n};\n\nexport default History;\n","import Router from \"./router.js\";\nimport History from \"./history.js\";\nimport serialize from \"./serialize.js\";\n\nmodule.exports.Router = Router;\nmodule.exports.History = History;\nmodule.exports.serialize = serialize;\n","import Augmented from \"augmentedjs-next\";\nimport History from \"./history.js\";\nimport Dom from \"presentation-dom\";\n\nconst _map = require(\"lodash.map\");\nconst _isRegExp = require(\"lodash.isregexp\");\n\n// Cached regular expressions for matching named param parts and splatted\n// parts of route strings.\nconst optionalParam = /\\((.*?)\\)/g;\nconst namedParam    = /(\\(\\?)?:\\w+/g;\nconst splatParam    = /\\*\\w+/g;\nconst escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n/**\n * Routers map faux-URLs to actions, and fire events when routes are\n * matched. Creating a new one sets its `routes` hash, if not set statically.<br/>\n * Supports passing routes to the constructor as well as a transition flag.\n * @example\n * const router = new Router({\n *    \"routes\": { ... },\n *    \"transition\": { \"in\": #, \"out\": # }\n * });\n * @extends Augmented.Object\n */\nclass Router extends Augmented.Object {\n  constructor(options) {\n    if (!options) {\n      options = {};\n    }\n    super(options);\n    if (options.routes) {\n      this.routes = options.routes;\n    }\n    if (options.transition) {\n      this.transition = options.transition;\n    }\n    this.history = new History();\n    this._bindRoutes();\n    this.initialize(options);\n  };\n\n  /**\n   * Parse a query string and return as an object\n   * @param {string} queryString\n   * @returns {object} Object of the query params\n   * @static\n   */\n  static parseQuery(queryString) {\n    let query = {},\n        pairs = (queryString[0] === \"?\" ? queryString.substr(1) : queryString).split(\"&\"),\n        i = 0;\n    const l = pairs.length;\n\n    for (i = 0; i < l; i++) {\n        const pair = pairs[i].split(\"=\");\n        query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || \"\");\n    }\n    return query;\n  };\n\n  /**\n   * @property {Presentation.View} view Read only property to current view\n   */\n  get view() {\n    return this._view;\n  };\n\n  /**\n   * Load a view safely and remove the last view by calling cleanup, then remove\n   * @param {View} view The View to load\n   */\n  loadView(view) {\n    //console.debug(\"router loadView\");\n    if (view) {\n      this._view = view;\n      if (this.transition && this.transition.in && this._view.el) {\n        const view = this._view;\n        const renderView = () => {\n          Dom.removeClass(view.el, \"transition-out\");\n          Dom.addClass(view.el, \"transition-in\");\n          //console.debug(\"view transition-in\");\n          if (view.render) {\n            view.render();\n          }\n          if (view.delegateEvents) {\n            view.delegateEvents();\n          }\n          return Promise.resolve(this);\n        };\n        Promise.all([\n          this.cleanup(),\n          window.setTimeout(renderView, this.transition.in)\n        ]);\n\n      } else {\n        if (this._view.render) {\n          this._view.render();\n        }\n        if (this._view.delegateEvents) {\n          this._view.delegateEvents();\n        }\n      }\n    }\n    return Promise.resolve(this);\n  };\n\n  /**\n   * Remove the last view by calling cleanup, then removes\n   */\n  cleanup() {\n    //console.debug(`router cleanup view '${(this._view) ? (this._view.name) : \"no view\"}'`);\n    if (this._view) {\n      //console.debug(`router cleanup view '${(this._view.el) ? (this._view.el) : \"no el\"}'`);\n      if (this.transition && this.transition.out && this._view.el) {\n        const view = this._view;\n        Dom.removeClass(view.el, \"transition-in\");\n        Dom.addClass(view.el, \"transition-out\");\n        //console.debug(\"view transition-out\");\n        const cleanupView = () => {\n          // TODO: deprecated\n          if (view.cleanup) {\n            console.warn(`View ${view.name}'s \"cleanup\" method is deprecated,\n              please add code to \"remove\" method.`);\n            view.cleanup();\n          }\n          if (view.remove) {\n            //console.debug(`router removing view ${this._view.remove()}`);\n            view.remove();\n          }\n          //view = null;\n          return Promise.resolve(this);\n        };\n        window.setTimeout(cleanupView, this.transition.out);\n      } else {\n        // TODO: deprecated\n        if (this._view.cleanup) {\n          console.warn(`View ${view.name}'s \"cleanup\" method is deprecated,\n            please add code to \"remove\" method.`);\n          this._view.cleanup();\n        }\n        if (this._view.remove) {\n          //console.debug(`router removing view ${this._view.remove()}`);\n          this._view.remove();\n        }\n        this._view = null;\n      }\n    }\n    return Promise.resolve(this);\n  };\n\n  /**\n   * Initialize is an empty function by default. Override it with your own\n   * initialization logic.\n   */\n  initialize(options) {\n    return super.initialize(options);\n  };\n\n  /**\n   * Manually bind a single named route to a callback.\n   * @param {string} route The route\n   * @param {string} name The function binding name\n   * @param {function} callback binding function\n   * @example\n   * this.route('search/:query/p:num', 'search', (query, num) => {\n   *   ...\n   * });\n   */\n  route(route, name, callback) {\n    if (!_isRegExp(route)) {\n      route = this._routeToRegExp(route);\n    }\n    if (Augmented.isFunction(name)) {\n      callback = name;\n      name = '';\n    }\n    if (!callback) {\n      callback = this[name];\n    }\n    const router = this;\n\n    this.history.route(route, (fragment) => {\n      const args = router._extractParameters(route, fragment);\n\n      if (router.execute(callback, args, name) !== false) {\n        router.trigger.apply(router, ['route:' + name].concat(args));\n        router.trigger('route', name, args);\n        this.history.trigger('route', router, name, args);\n      }\n    });\n    return this;\n  };\n\n  /**\n   * Execute a route handler with the provided parameters.  This is an\n   * excellent place to do pre-route setup or post-route cleanup.\n   * @param {function} callback binding function\n   * @param {array} args The arges passed\n   */\n  execute(callback, args) {\n    if (callback) {\n      callback.apply(this, args);\n    }\n  };\n\n  /**\n   * Simple proxy to `history` to save a fragment into the history.\n   * @param {string} fragment route fragment\n   * @param {object} options any options to pass\n   */\n  navigate(fragment, options) {\n    this.history.navigate(fragment, options);\n    return { \"routes\": this.routes };\n  };\n\n  /**\n   * Start the history using browser History API\n   * @param {object} options any options to pass\n   */\n  startHistory(options) {\n    if (!this.history.started) {\n      this.history.start(options);\n    }\n    return true;\n  };\n\n  // Bind all defined routes to `history`. We have to reverse the\n  // order of the routes here to support behavior where the most general\n  // routes can be defined at the bottom of the route map.\n  _bindRoutes() {\n    if (!this.routes) {\n      return;\n    }\n    this.routes = Augmented.result(this, \"routes\");\n    let route,\n        routes = Object.keys(this.routes);\n    while ((route = routes.pop()) != null) {\n      this.route(route, this.routes[route]);\n    }\n  };\n\n  // Convert a route string into a regular expression, suitable for matching\n  // against the current location hash.\n  _routeToRegExp(route) {\n    route = route.replace(escapeRegExp, '\\\\$&')\n                 .replace(optionalParam, '(?:$1)?')\n                 .replace(namedParam, (match, optional) => {\n                   return optional ? match : '([^/?]+)';\n                 })\n                 .replace(splatParam, '([^?]*?)');\n    return new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$');\n  };\n\n  // Given a route, and a URL fragment that it matches, return the array of\n  // extracted decoded parameters. Empty or unmatched parameters will be\n  // treated as `null` to normalize cross-browser behavior.\n  _extractParameters(route, fragment) {\n    let params = route.exec(fragment).slice(1);\n    return _map(params, (param, i) => {\n      // Don't decode the search params.\n      if (i === params.length - 1) {\n        return param || null;\n      }\n      return param ? decodeURIComponent(param) : null;\n    });\n  };\n};\n\nexport default Router;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__4__;","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","module.exports = __WEBPACK_EXTERNAL_MODULE__6__;","/**\n * Serialize object into query parameters url string\n * @function serialize\n * @memberof Utilities\n * @param {object} obj Object to serialize\n * @returns {string} URL string\n */\nconst serialize = (obj) => {\n  let str = [], p = null;\n  for (p in obj) {\n    if (obj.hasOwnProperty(p)) {\n      str.push(`${encodeURIComponent(p)}=${encodeURIComponent(obj[p])}`);\n    }\n  }\n  return str.join(\"&\");\n};\n\nexport default serialize;\n"],"sourceRoot":""}