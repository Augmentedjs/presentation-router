{"version":3,"sources":["webpack://presentation-router/webpack/universalModuleDefinition","webpack://presentation-router/webpack/bootstrap","webpack://presentation-router/external {\"commonjs\":\"next-core-utilities\",\"commonjs2\":\"next-core-utilities\",\"amd\":\"next-core-utilities\",\"root\":\"next-core-utilities\"}","webpack://presentation-router/external {\"commonjs\":\"next-core-object\",\"commonjs2\":\"next-core-object\",\"amd\":\"next-core-object\",\"root\":\"next-core-object\"}","webpack://presentation-router/external {\"commonjs\":\"presentation-dom\",\"commonjs2\":\"presentation-dom\",\"amd\":\"presentation-dom\",\"root\":\"presentation-dom\"}","webpack://presentation-router/external {\"commonjs\":\"lodash.map\",\"commonjs2\":\"lodash.map\",\"amd\":\"lodash.map\",\"root\":\"lodash.map\"}","webpack://presentation-router/external {\"commonjs\":\"lodash.isregexp\",\"commonjs2\":\"lodash.isregexp\",\"amd\":\"lodash.isregexp\",\"root\":\"lodash.isregexp\"}","webpack://presentation-router/./src/history.js","webpack://presentation-router/./src/router.js","webpack://presentation-router/./src/serialize.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__2__","__WEBPACK_EXTERNAL_MODULE__3__","__WEBPACK_EXTERNAL_MODULE__4__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ROUTE_STRIPPER","ROOT_STRIPPER","PATH_STRIPPER","History","AugmentedObject","constructor","options","super","handlers","checkUrl","window","location","history","interval","started","atRoot","pathname","replace","getSearch","matchRoot","decodeFragment","slice","length","fragment","decodeURI","match","href","getHash","getPath","path","charAt","getFragment","_usePushState","_wantsHashChange","start","Error","extend","hashChange","_hasHashChange","document","documentMode","_useHashChange","_wantsPushState","pushState","_hasPushState","rootPath","navigate","iframe","createElement","src","style","display","tabIndex","body","iWindow","insertBefore","firstChild","contentWindow","open","close","hash","addEventListener","eventName","listener","attachEvent","_checkUrlInterval","setInterval","silent","loadUrl","stop","removeEventListener","detachEvent","removeChild","clearInterval","route","callback","unshift","e","current","Array","isArray","some","handler","test","trigger","url","title","assign","_updateHash","_map","_isRegExp","optionalParam","namedParam","splatParam","escapeRegExp","Router","routes","transition","_bindRoutes","initialize","queryString","query","pairs","substr","split","pair","decodeURIComponent","_view","view","oldView","in","Dom","addClass","el","cleanup","setTimeout","out","render","removeClass","delegateEvents","console","warn","error","cleanupView","async","remove","_routeToRegExp","isFunction","router","args","_extractParameters","execute","apply","concat","startHistory","result","keys","pop","optional","RegExp","params","exec","param","serialize","obj","str","push","encodeURIComponent","join"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,uBAAwBA,QAAQ,oBAAqBA,QAAQ,oBAAqBA,QAAQ,cAAeA,QAAQ,oBACzH,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,sBAAuB,CAAC,sBAAuB,mBAAoB,mBAAoB,aAAc,mBAAoBJ,GACtG,iBAAZC,QACdA,QAAQ,uBAAyBD,EAAQG,QAAQ,uBAAwBA,QAAQ,oBAAqBA,QAAQ,oBAAqBA,QAAQ,cAAeA,QAAQ,oBAElKJ,EAAK,uBAAyBC,EAAQD,EAAK,uBAAwBA,EAAK,oBAAqBA,EAAK,oBAAqBA,EAAK,cAAeA,EAAK,oBARlJ,CASGO,MAAM,SAASC,EAAgCC,EAAgCC,EAAgCC,EAAgCC,GAClJ,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUb,QAGnC,IAAIC,EAASU,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHf,QAAS,IAUV,OANAgB,EAAQH,GAAUI,KAAKhB,EAAOD,QAASC,EAAQA,EAAOD,QAASY,GAG/DX,EAAOc,GAAI,EAGJd,EAAOD,QA0Df,OArDAY,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASpB,EAASqB,EAAMC,GAC3CV,EAAoBW,EAAEvB,EAASqB,IAClCG,OAAOC,eAAezB,EAASqB,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAS5B,GACX,oBAAX6B,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAezB,EAAS6B,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAezB,EAAS,aAAc,CAAE+B,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAStC,GAChC,IAAIqB,EAASrB,GAAUA,EAAOiC,WAC7B,WAAwB,OAAOjC,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAW,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,SAIjBhC,EAAoBA,EAAoBiC,EAAI,G,gBClFrD5C,EAAOD,QAAUM,G,cCAjBL,EAAOD,QAAUO,G,cCAjBN,EAAOD,QAAUQ,G,cCAjBP,EAAOD,QAAUS,G,cCAjBR,EAAOD,QAAUU,G,+KCMjB,MAAMoC,EAAiB,eAGjBC,EAAgB,aAGhBC,EAAgB,OAStB,MAAMC,UAAgBC,kBACpBC,YAAYC,GACVC,MAAMD,GACN/C,KAAKiD,SAAW,GAChBjD,KAAKkD,SAAWlD,KAAKkD,SAASjB,KAAKjC,MAGb,oBAAXmD,SACTnD,KAAKoD,SAAWD,OAAOC,SACvBpD,KAAKqD,QAAUF,OAAOE,SAKxBrD,KAAKsD,SAAW,GAGhBtD,KAAKuD,SAAU,EAIjBC,SAEE,OADWxD,KAAKoD,SAASK,SAASC,QAAQ,SAAU,SACpC1D,KAAKP,OAASO,KAAK2D,YAIrCC,YAIE,OAHa5D,KAAK6D,eAAe7D,KAAKoD,SAASK,UACzBK,MAAM,EAAG9D,KAAKP,KAAKsE,OAAS,GAAK,MAEnC/D,KAAKP,KAM3BoE,eAAeG,GACb,OAAOC,UAAUD,EAASN,QAAQ,OAAQ,UAK5CC,YACE,MAAMO,EAAQlE,KAAKoD,SAASe,KAAKT,QAAQ,MAAO,IAAIQ,MAAM,QAC1D,OAAOA,EAAQA,EAAM,GAAK,GAK5BE,QAAQjB,GACN,MAAMe,GAASf,GAAUnD,MAAMoD,SAASe,KAAKD,MAAM,UACnD,OAAOA,EAAQA,EAAM,GAAK,GAI5BG,UACE,MAAMC,EAAOtE,KAAK6D,eAChB7D,KAAKoD,SAASK,SAAWzD,KAAK2D,aAC9BG,MAAM9D,KAAKP,KAAKsE,OAAS,GAC3B,MAA0B,MAAnBO,EAAKC,OAAO,GAAaD,EAAKR,MAAM,GAAKQ,EAIlDE,YAAYR,GAQV,OAPgB,MAAZA,IAEAA,EADEhE,KAAKyE,gBAAkBzE,KAAK0E,iBACnB1E,KAAKqE,UAELrE,KAAKoE,WAGbJ,EAASN,QAAQjB,EAAgB,IAK1CkC,MAAM5B,GACJ,GAAI/C,KAAKuD,QACP,MAAM,IAAIqB,MAAM,oCAqBlB,GAnBA5E,KAAKuD,SAAU,EAIfvD,KAAK+C,QAAmB8B,iBAAO,CAACpF,KAAM,KAAMO,KAAK+C,QAASA,GAC1D/C,KAAKP,KAAmBO,KAAK+C,QAAQtD,KACrCO,KAAK0E,kBAA+C,IAA5B1E,KAAK+C,QAAQ+B,WACrC9E,KAAK+E,eAAmB,iBAAkB5B,cAAqC,IAA1B6B,SAASC,cAA2BD,SAASC,aAAe,GACjHjF,KAAKkF,eAAmBlF,KAAK0E,kBAAoB1E,KAAK+E,eACtD/E,KAAKmF,kBAAqBnF,KAAK+C,QAAQqC,UACvCpF,KAAKqF,iBAAsBrF,KAAKqD,UAAWrD,KAAKqD,QAAQ+B,WACxDpF,KAAKyE,cAAmBzE,KAAKmF,iBAAmBnF,KAAKqF,cACrDrF,KAAKgE,SAAmBhE,KAAKwE,cAG7BxE,KAAKP,KAAS,IAAGO,KAAKP,QAASiE,QAAQhB,EAAe,KAIlD1C,KAAK0E,kBAAoB1E,KAAKmF,gBAAiB,CAIjD,IAAKnF,KAAKqF,gBAAkBrF,KAAKwD,SAAU,CACzC,MAAM8B,EAAWtF,KAAKP,KAAKqE,MAAM,GAAI,IAAM,IAG3C,OAFA9D,KAAKoD,SAASM,QAAS,GAAE4B,KAAYtF,KAAKqE,cAEnC,EAIErE,KAAKqF,eAAiBrF,KAAKwD,UACpCxD,KAAKuF,SAASvF,KAAKoE,UAAW,CAACV,SAAS,IAO5C,IAAK1D,KAAK+E,gBAAkB/E,KAAK0E,mBAAqB1E,KAAKyE,cAAe,CACxEzE,KAAKwF,OAASR,SAASS,cAAc,UACrCzF,KAAKwF,OAAOE,IAAM,eAClB1F,KAAKwF,OAAOG,MAAMC,QAAU,OAC5B5F,KAAKwF,OAAOK,UAAY,EACxB,MAAMC,EAAOd,SAASc,KAEhBC,EAAUD,EAAKE,aAAahG,KAAKwF,OAAQM,EAAKG,YAAYC,cAChEH,EAAQf,SAASmB,OACjBJ,EAAQf,SAASoB,QACjBL,EAAQ3C,SAASiD,KAAO,IAAMrG,KAAKgE,SAGrC,MAKMsC,EAAoBnD,OAAOmD,iBAAoBnD,OAAOmD,iBAL/C,CAACC,EAAWC,IAChBC,YAAY,KAAOF,EAAWC,GAgBvC,GARIxG,KAAKyE,cACP6B,EAAiB,WAAYtG,KAAKkD,UAAU,GACnClD,KAAKkF,iBAAmBlF,KAAKwF,OACtCc,EAAiB,aAActG,KAAKkD,UAAU,GACrClD,KAAK0E,mBACd1E,KAAK0G,kBAAoBC,YAAY3G,KAAKkD,SAAUlD,KAAKsD,YAGtDtD,KAAK+C,QAAQ6D,OAChB,OAAO5G,KAAK6G,UAMhBC,OACE,MAKMC,EAAuB5D,OAAO4D,oBAAwB5D,OAAO4D,oBALtD,CAACR,EAAWC,IAChBQ,YAAY,KAAOT,EAAWC,GAOnCxG,KAAKyE,cACPsC,EAAoB,WAAY/G,KAAKkD,UAAU,GACtClD,KAAKkF,iBAAmBlF,KAAKwF,QACtCuB,EAAoB,aAAc/G,KAAKkD,UAAU,GAI/ClD,KAAKwF,SACPR,SAASc,KAAKmB,YAAYjH,KAAKwF,QAC/BxF,KAAKwF,OAAS,MAIZxF,KAAK0G,mBACPQ,cAAclH,KAAK0G,mBAErB1G,KAAKuD,SAAU,EAKjB4D,MAAMA,EAAOC,GACXpH,KAAKiD,SAASoE,QAAQ,CAACF,MAAOA,EAAOC,SAAUA,IAKjDlE,SAASoE,GACP,IAAIC,EAAUvH,KAAKwE,cAQnB,GAJI+C,IAAYvH,KAAKgE,UAAYhE,KAAKwF,SACpC+B,EAAUvH,KAAKoE,QAAQpE,KAAKwF,OAAOU,gBAGjCqB,IAAYvH,KAAKgE,SACnB,OAAO,EAELhE,KAAKwF,QAAQxF,KAAKuF,SAASgC,GAC/BvH,KAAK6G,UAMPA,QAAQ7C,GAEN,QAAKhE,KAAK4D,cAGVI,EAAWhE,KAAKgE,SAAWhE,KAAKwE,YAAYR,GAGxChE,KAAKiD,UAAYuE,MAAMC,QAAQzH,KAAKiD,UAC/BjD,KAAKiD,SAASyE,KAAMC,IAEzB,GAAIA,EAAQR,MAAMS,KAAK5D,GAKrB,OAFA2D,EAAQP,SAASpD,IAEV,IAIN,MAiBTuB,SAASvB,EAAUjB,GACjB,IAAK/C,KAAKuD,QACR,OAAO,EAEJR,IAAuB,IAAZA,IACdA,EAAU,CAAC8E,UAAW9E,IAIxBiB,EAAWhE,KAAKwE,YAAYR,GAAY,IAGxC,IAAIsB,EAAWtF,KAAKP,KACH,KAAbuE,GAA0C,MAAvBA,EAASO,OAAO,KACrCe,EAAWA,EAASxB,MAAM,GAAI,IAAM,KAEtC,MAAMgE,EAAMxC,EAAWtB,EAKvB,GAFAA,EAAWhE,KAAK6D,eAAeG,EAASN,QAAQf,EAAe,KAE3D3C,KAAKgE,WAAaA,EAAtB,CAMA,GAHAhE,KAAKgE,SAAWA,EAGZhE,KAAKyE,cACPzE,KAAKqD,QAAQN,EAAQW,QAAU,eAAiB,aAAa,GAAIsB,SAAS+C,MAAOD,OAI5E,KAAI9H,KAAK0E,iBAmBd,OAAO1E,KAAKoD,SAAS4E,OAAOF,GAjB5B,GADA9H,KAAKiI,YAAYjI,KAAKoD,SAAUY,EAAUjB,EAAQW,SAC9C1D,KAAKwF,QAAUxB,IAAahE,KAAKoE,QAAQpE,KAAKwF,OAAOU,eAAgB,CACvE,MAAMH,EAAU/F,KAAKwF,OAAOU,cAKvBnD,EAAQW,UACXqC,EAAQf,SAASmB,OACjBJ,EAAQf,SAASoB,SAGnBpG,KAAKiI,YAAYlC,EAAQ3C,SAAUY,EAAUjB,EAAQW,UAQzD,OAAIX,EAAQ8E,QACH7H,KAAK6G,QAAQ7C,QADtB,GAOFiE,YAAY7E,EAAUY,EAAUN,GAC9B,GAAIA,EAAS,CACX,MAAMS,EAAOf,EAASe,KAAKT,QAAQ,qBAAsB,IACzDN,EAASM,QAAQS,EAAO,IAAMH,QAG9BZ,EAASiD,KAAO,IAAMrC,GAKbpB,Q,gBChVf,MAAMsF,EAAOrI,EAAQ,GACfsI,EAAYtI,EAAQ,GAIpBuI,EAAgB,aAChBC,EAAgB,eAChBC,EAAgB,SAChBC,EAAgB,2BAatB,MAAMC,UAAe3F,kBACnBC,YAAYC,GACLA,IACHA,EAAU,IAEZC,MAAMD,GACFA,EAAQ0F,SACVzI,KAAKyI,OAAS1F,EAAQ0F,QAEpB1F,EAAQ2F,aACV1I,KAAK0I,WAAa3F,EAAQ2F,YAE5B1I,KAAKqD,QAAU,IAAIT,EACnB5C,KAAK2I,cACL3I,KAAK4I,WAAW7F,GASlB,kBAAkB8F,GAChB,IAAIC,EAAQ,GACRC,GAA4B,MAAnBF,EAAY,GAAaA,EAAYG,OAAO,GAAKH,GAAaI,MAAM,KAC7ExI,EAAI,EACR,MAAMC,EAAIqI,EAAMhF,OAEhB,IAAKtD,EAAI,EAAGA,EAAIC,EAAGD,IAAK,CACpB,MAAMyI,EAAOH,EAAMtI,GAAGwI,MAAM,KAC5BH,EAAMK,mBAAmBD,EAAK,KAAOC,mBAAmBD,EAAK,IAAM,IAEvE,OAAOJ,EAMT,WACE,OAAO9I,KAAKoJ,MAOd,eAAeC,GACb,IAEE,GAAIA,EAAM,CACR,MAAMC,EAAUtJ,KAAKoJ,MACjBpJ,KAAK0I,YAAc1I,KAAK0I,WAAWa,IAEjCD,UAEIE,IAAIC,SAASJ,EAAKK,GAAI,wBAEtB1J,KAAK2J,iBAGPxG,OAAOyG,WAAW,OAGrB5J,KAAK0I,WAAWmB,KAEfR,EAAKS,cACD3G,OAAOyG,WAAW,KAItBJ,IAAIO,YAAYV,EAAKK,GAAI,kBACzBL,EAAKS,UACJ9J,KAAK0I,WAAWa,IAGjBF,EAAKW,sBACDX,EAAKW,iBAGbhK,KAAKoJ,MAAQC,IAETC,SACItJ,KAAK2J,QAAQL,SAEfD,EAAKS,SACPT,EAAKW,sBACDX,EAAKW,iBAEbhK,KAAKoJ,MAAQC,QAIfY,QAAQC,KAAK,mBAEf,MAAM5C,GACN2C,QAAQE,MAAM7C,GAEhB,OAAOtH,KAMT,cAAcsJ,GAEZ,GAAIA,GAAWtJ,KAAKoJ,MAAO,CAEzB,MAAMC,EAAQC,GAAqBtJ,KAAKoJ,MACxC,GAAIpJ,KAAK0I,YAAc1I,KAAK0I,WAAWmB,KAAOR,EAAKK,GAAI,CAGrD,MAAMU,EAAcC,UAMdhB,EAAKiB,cAEDjB,EAAKiB,SAGNjB,SAEHlG,OAAOyG,WAAWQ,EAAapK,KAAK0I,WAAWmB,KACrD7J,KAAKoJ,MAAQ,UAETpJ,KAAKqJ,KAAKiB,cAENtK,KAAKqJ,KAAKiB,SAElBtK,KAAKoJ,MAAQ,KAKjB,OAAOpJ,KAOT4I,WAAW7F,GACT,OAAOC,MAAM4F,WAAW7F,GAa1BoE,MAAMA,EAAOnG,EAAMoG,GACZe,EAAUhB,KACbA,EAAQnH,KAAKuK,eAAepD,IAE1BqD,qBAAWxJ,KACboG,EAAWpG,EACXA,EAAO,IAEJoG,IACHA,EAAWpH,KAAKgB,IAElB,MAAMyJ,EAASzK,KAWf,OATAA,KAAKqD,QAAQ8D,MAAMA,EAAQnD,IACzB,MAAM0G,EAAOD,EAAOE,mBAAmBxD,EAAOnD,IAED,IAAzCyG,EAAOG,QAAQxD,EAAUsD,EAAM1J,KACjCyJ,EAAO5C,QAAQgD,MAAMJ,EAAQ,CAAC,SAAWzJ,GAAM8J,OAAOJ,IACtDD,EAAO5C,QAAQ,QAAS7G,EAAM0J,GAC9B1K,KAAKqD,QAAQwE,QAAQ,QAAS4C,EAAQzJ,EAAM0J,MAGzC1K,KAST4K,QAAQxD,EAAUsD,GACZtD,GACFA,EAASyD,MAAM7K,KAAM0K,GASzBnF,SAASvB,EAAUjB,GAEjB,OADA/C,KAAKqD,QAAQkC,SAASvB,EAAUjB,GACzB,CAAE,OAAU/C,KAAKyI,QAO1BsC,aAAahI,GAIX,OAHK/C,KAAKqD,QAAQE,SAChBvD,KAAKqD,QAAQsB,MAAM5B,IAEd,EAMT4F,cACE,IAAK3I,KAAKyI,OACR,OAEFzI,KAAKyI,OAASuC,iBAAOhL,KAAM,UAC3B,IAAImH,EACAsB,EAAStH,OAAO8J,KAAKjL,KAAKyI,QAC9B,KAAiC,OAAzBtB,EAAQsB,EAAOyC,QACrBlL,KAAKmH,MAAMA,EAAOnH,KAAKyI,OAAOtB,IAMlCoD,eAAepD,GAOb,OANAA,EAAQA,EAAMzD,QAAQ6E,EAAc,QACtB7E,QAAQ0E,EAAe,WACvB1E,QAAQ2E,EAAY,CAACnE,EAAOiH,IACpBA,EAAWjH,EAAQ,YAE3BR,QAAQ4E,EAAY,YAC3B,IAAI8C,OAAO,IAAMjE,EAAQ,wBAMlCwD,mBAAmBxD,EAAOnD,GACxB,IAAIqH,EAASlE,EAAMmE,KAAKtH,GAAUF,MAAM,GACxC,OAAOoE,EAAKmD,EAAQ,CAACE,EAAO9K,IAEtBA,IAAM4K,EAAOtH,OAAS,EACjBwH,GAAS,KAEXA,EAAQpC,mBAAmBoC,GAAS,OAKlC/C,QC3QAgD,MAVIC,IACjB,IAAIC,EAAM,GAAInJ,EAAI,KAClB,IAAKA,KAAKkJ,EACJA,EAAInJ,eAAeC,IACrBmJ,EAAIC,KAAM,GAAEC,mBAAmBrJ,MAAMqJ,mBAAmBH,EAAIlJ,OAGhE,OAAOmJ,EAAIG,KAAK","file":"presentation-router.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"next-core-utilities\"), require(\"next-core-object\"), require(\"presentation-dom\"), require(\"lodash.map\"), require(\"lodash.isregexp\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"presentation-router\", [\"next-core-utilities\", \"next-core-object\", \"presentation-dom\", \"lodash.map\", \"lodash.isregexp\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"presentation-router\"] = factory(require(\"next-core-utilities\"), require(\"next-core-object\"), require(\"presentation-dom\"), require(\"lodash.map\"), require(\"lodash.isregexp\"));\n\telse\n\t\troot[\"presentation-router\"] = factory(root[\"next-core-utilities\"], root[\"next-core-object\"], root[\"presentation-dom\"], root[\"lodash.map\"], root[\"lodash.isregexp\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__3__, __WEBPACK_EXTERNAL_MODULE__4__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","module.exports = __WEBPACK_EXTERNAL_MODULE__4__;","import { AugmentedObject } from \"next-core-object\";\nimport { extend } from \"next-core-utilities\";\n\n//const _some = require(\"lodash.some\");\n\n// Cached regex for stripping a leading hash/slash and trailing space.\nconst ROUTE_STRIPPER = /^[#\\/]|\\s+$/g;\n\n// Cached regex for stripping leading and trailing slashes.\nconst ROOT_STRIPPER = /^\\/+|\\/+$/g;\n\n// Cached regex for stripping urls of hash.\nconst PATH_STRIPPER = /#.*$/;\n\n/**\n * Handles cross-browser history management, based on either\n * [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n * [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n * and URL fragments.\n * @extends AugmentedObject\n */\nclass History extends AugmentedObject {\n  constructor(options) {\n    super(options);\n    this.handlers = [];\n    this.checkUrl = this.checkUrl.bind(this);\n\n    // Ensure that `History` can be used outside of the browser.\n    if (typeof window !== \"undefined\") {\n      this.location = window.location;\n      this.history = window.history;\n    }\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    this.interval = 50;\n\n    // Has the history handling already been started?\n    this.started = false;\n  };\n\n  // Are we at the app root?\n  atRoot() {\n    let path = this.location.pathname.replace(/[^\\/]$/, '$&/');\n    return path === this.root && !this.getSearch();\n  };\n\n  // Does the pathname match the root?\n  matchRoot() {\n    const path = this.decodeFragment(this.location.pathname);\n    const rootPath = path.slice(0, this.root.length - 1) + '/';\n    //console.log(`History: matchRoot ${rootPath} and root is ${this.root}`);\n    return rootPath === this.root;\n  };\n\n  // Unicode characters in `location.pathname` are percent encoded so they're\n  // decoded for comparison. `%25` should not be decoded since it may be part\n  // of an encoded parameter.\n  decodeFragment(fragment) {\n    return decodeURI(fragment.replace(/%25/g, '%2525'));\n  };\n\n  // In IE6, the hash fragment and search params are incorrect if the\n  // fragment contains `?`.\n  getSearch() {\n    const match = this.location.href.replace(/#.*/, '').match(/\\?.+/);\n    return match ? match[0] : '';\n  };\n\n  // Gets the true hash value. Cannot use location.hash directly due to bug\n  // in Firefox where location.hash will always be decoded.\n  getHash(window) {\n    const match = (window || this).location.href.match(/#(.*)$/);\n    return match ? match[1] : '';\n  };\n\n  // Get the pathname and search params, without the root.\n  getPath() {\n    const path = this.decodeFragment(\n      this.location.pathname + this.getSearch()\n    ).slice(this.root.length - 1);\n    return path.charAt(0) === '/' ? path.slice(1) : path;\n  };\n\n  // Get the cross-browser normalized URL fragment from the path or hash.\n  getFragment(fragment) {\n    if (fragment == null) {\n      if (this._usePushState || !this._wantsHashChange) {\n        fragment = this.getPath();\n      } else {\n        fragment = this.getHash();\n      }\n    }\n    return fragment.replace(ROUTE_STRIPPER, '');\n  };\n\n  // Start the hash change handling, returning `true` if the current URL matches\n  // an existing route, and `false` otherwise.\n  start(options) {\n    if (this.started) {\n      throw new Error('History has already been started');\n    }\n    this.started = true;\n\n    // Figure out the initial configuration. Do we need an iframe?\n    // Is pushState desired ... is it available?\n    this.options          = extend({root: '/'}, this.options, options);\n    this.root             = this.options.root;\n    this._wantsHashChange = this.options.hashChange !== false;\n    this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);\n    this._useHashChange   = this._wantsHashChange && this._hasHashChange;\n    this._wantsPushState  = !!this.options.pushState;\n    this._hasPushState    = !!(this.history && this.history.pushState);\n    this._usePushState    = this._wantsPushState && this._hasPushState;\n    this.fragment         = this.getFragment();\n\n    // Normalize root to always include a leading and trailing slash.\n    this.root = (`/${this.root}/`).replace(ROOT_STRIPPER, '/');\n\n    // Transition from hashChange to pushState or vice versa if both are\n    // requested.\n    if (this._wantsHashChange && this._wantsPushState) {\n\n      // If we've started off with a route from a `pushState`-enabled\n      // browser, but we're currently in a browser that doesn't support it...\n      if (!this._hasPushState && !this.atRoot()) {\n        const rootPath = this.root.slice(0, -1) || \"/\";\n        this.location.replace(`${rootPath}#${this.getPath()}`);\n        // Return immediately as browser will do redirect to new url\n        return true;\n\n      // Or if we've started out with a hash-based route, but we're currently\n      // in a browser where it could be `pushState`-based instead...\n      } else if (this._hasPushState && this.atRoot()) {\n        this.navigate(this.getHash(), {replace: true});\n      }\n    }\n\n    // Proxy an iframe to handle location events if the browser doesn't\n    // support the `hashchange` event, HTML5 history, or the user wants\n    // `hashChange` but not `pushState`.\n    if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {\n      this.iframe = document.createElement('iframe');\n      this.iframe.src = 'javascript:0';\n      this.iframe.style.display = 'none';\n      this.iframe.tabIndex = -1;\n      const body = document.body;\n      // Using `appendChild` will throw on IE < 9 if the document is not ready.\n      const iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;\n      iWindow.document.open();\n      iWindow.document.close();\n      iWindow.location.hash = '#' + this.fragment;\n    }\n\n    const poly = (eventName, listener) => {\n      return attachEvent('on' + eventName, listener);\n    };\n\n    // Add a cross-platform `addEventListener` shim for older browsers.\n    const addEventListener = (window.addEventListener) ? window.addEventListener : poly;\n\n    // Depending on whether we're using pushState or hashes, and whether\n    // 'onhashchange' is supported, determine how we check the URL state.\n    if (this._usePushState) {\n      addEventListener('popstate', this.checkUrl, false);\n    } else if (this._useHashChange && !this.iframe) {\n      addEventListener('hashchange', this.checkUrl, false);\n    } else if (this._wantsHashChange) {\n      this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n    }\n\n    if (!this.options.silent) {\n      return this.loadUrl();\n    }\n  };\n\n  // Disable history, perhaps temporarily. Not useful in a real app,\n  // but possibly useful for unit testing Routers.\n  stop() {\n    const poly = (eventName, listener) => {\n      return detachEvent('on' + eventName, listener);\n    };\n\n    // Add a cross-platform `removeEventListener` shim for older browsers.\n    const removeEventListener = (window.removeEventListener) ?  window.removeEventListener : poly;\n\n    // Remove window listeners.\n    if (this._usePushState) {\n      removeEventListener('popstate', this.checkUrl, false);\n    } else if (this._useHashChange && !this.iframe) {\n      removeEventListener('hashchange', this.checkUrl, false);\n    }\n\n    // Clean up the iframe if necessary.\n    if (this.iframe) {\n      document.body.removeChild(this.iframe);\n      this.iframe = null;\n    }\n\n    // Some environments will throw when clearing an undefined interval.\n    if (this._checkUrlInterval) {\n      clearInterval(this._checkUrlInterval);\n    }\n    this.started = false;\n  };\n\n  // Add a route to be tested when the fragment changes. Routes added later\n  // may override previous routes.\n  route(route, callback) {\n    this.handlers.unshift({route: route, callback: callback});\n  };\n\n  // Checks the current URL to see if it has changed, and if it has,\n  // calls `loadUrl`, normalizing across the hidden iframe.\n  checkUrl(e) {\n    let current = this.getFragment();\n\n    // If the user pressed the back button, the iframe's hash will have\n    // changed and we should use that for comparison.\n    if (current === this.fragment && this.iframe) {\n      current = this.getHash(this.iframe.contentWindow);\n    }\n\n    if (current === this.fragment) {\n      return false;\n    }\n    if (this.iframe) this.navigate(current);\n    this.loadUrl();\n  };\n\n  // Attempt to load the current URL fragment. If a route succeeds with a\n  // match, returns `true`. If no defined routes matches the fragment,\n  // returns `false`.\n  loadUrl(fragment) {\n    // If the root doesn't match, no routes can match either.\n    if (!this.matchRoot()) {\n      return false;\n    }\n    fragment = this.fragment = this.getFragment(fragment);\n    //console.log(\"loadUrl\", fragment);\n    //console.log(\"this.handlers\", this.handlers);\n    if (this.handlers && Array.isArray(this.handlers)) {\n      return this.handlers.some((handler) => {\n        //console.log(\"handler\", handler);\n        if (handler.route.test(fragment)) {\n          //console.log(\"handler.callback\", handler.callback);\n          //console.log(\"is func\", typeof handler.callback);\n          handler.callback(fragment);\n          //console.log(\"test\", handler.route.test(fragment));\n          return true;\n        }\n      });\n    }\n    return null;\n\n    /*return _some(this.handlers, (handler) => {\n      if (handler.route.test(fragment)) {\n        handler.callback(fragment);\n        return true;\n      }\n    });*/\n  };\n\n  // Save a fragment into the hash history, or replace the URL state if the\n  // 'replace' option is passed. You are responsible for properly URL-encoding\n  // the fragment in advance.\n  //\n  // The options object can contain `trigger: true` if you wish to have the\n  // route callback be fired (not usually desirable), or `replace: true`, if\n  // you wish to modify the current URL without adding an entry to the history.\n  navigate(fragment, options) {\n    if (!this.started) {\n      return false;\n    }\n    if (!options || options === true) {\n      options = {trigger: !!options};\n    }\n\n    // Normalize the fragment.\n    fragment = this.getFragment(fragment || '');\n\n    // Don't include a trailing slash on the root.\n    let rootPath = this.root;\n    if (fragment === '' || fragment.charAt(0) === '?') {\n      rootPath = rootPath.slice(0, -1) || '/';\n    }\n    const url = rootPath + fragment;\n\n    // Strip the hash and decode for matching.\n    fragment = this.decodeFragment(fragment.replace(PATH_STRIPPER, ''));\n\n    if (this.fragment === fragment) {\n      return;\n    }\n    this.fragment = fragment;\n\n    // If pushState is available, we use it to set the fragment as a real URL.\n    if (this._usePushState) {\n      this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n    // If hash changes haven't been explicitly disabled, update the hash\n    // fragment to store history.\n    } else if (this._wantsHashChange) {\n      this._updateHash(this.location, fragment, options.replace);\n      if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {\n        const iWindow = this.iframe.contentWindow;\n\n        // Opening and closing the iframe tricks IE7 and earlier to push a\n        // history entry on hash-tag change.  When replace is true, we don't\n        // want this.\n        if (!options.replace) {\n          iWindow.document.open();\n          iWindow.document.close();\n        }\n\n        this._updateHash(iWindow.location, fragment, options.replace);\n      }\n\n    // If you've told us that you explicitly don't want fallback hashchange-\n    // based history, then `navigate` becomes a page refresh.\n    } else {\n      return this.location.assign(url);\n    }\n    if (options.trigger) {\n      return this.loadUrl(fragment);\n    }\n  };\n\n  // Update the hash location, either replacing the current entry, or adding\n  // a new one to the browser history.\n  _updateHash(location, fragment, replace) {\n    if (replace) {\n      const href = location.href.replace(/(javascript:|#).*$/, '');\n      location.replace(href + '#' + fragment);\n    } else {\n      // Some browsers require that `hash` contains a leading #.\n      location.hash = '#' + fragment;\n    }\n  }\n};\n\nexport default History;\n","import { AugmentedObject } from \"next-core-object\";\nimport { result, isFunction } from \"next-core-utilities\";\nimport History from \"./history.js\";\nimport Dom from \"presentation-dom\";\n\nconst _map = require(\"lodash.map\");\nconst _isRegExp = require(\"lodash.isregexp\");\n\n// Cached regular expressions for matching named param parts and splatted\n// parts of route strings.\nconst optionalParam = /\\((.*?)\\)/g;\nconst namedParam    = /(\\(\\?)?:\\w+/g;\nconst splatParam    = /\\*\\w+/g;\nconst escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n/**\n * Routers map faux-URLs to actions, and fire events when routes are\n * matched. Creating a new one sets its `routes` hash, if not set statically.<br/>\n * Supports passing routes to the constructor as well as a transition flag.\n * @example\n * const router = new Router({\n *    \"routes\": { ... },\n *    \"transition\": { \"in\": #, \"out\": # }\n * });\n * @extends AugmentedObject\n */\nclass Router extends AugmentedObject {\n  constructor(options) {\n    if (!options) {\n      options = {};\n    }\n    super(options);\n    if (options.routes) {\n      this.routes = options.routes;\n    }\n    if (options.transition) {\n      this.transition = options.transition;\n    }\n    this.history = new History();\n    this._bindRoutes();\n    this.initialize(options);\n  };\n\n  /**\n   * Parse a query string and return as an object\n   * @param {string} queryString\n   * @returns {object} Object of the query params\n   * @static\n   */\n  static parseQuery(queryString) {\n    let query = {},\n        pairs = (queryString[0] === \"?\" ? queryString.substr(1) : queryString).split(\"&\"),\n        i = 0;\n    const l = pairs.length;\n\n    for (i = 0; i < l; i++) {\n        const pair = pairs[i].split(\"=\");\n        query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || \"\");\n    }\n    return query;\n  };\n\n  /**\n   * @property {Presentation.View} view Read only property to current view\n   */\n  get view() {\n    return this._view;\n  };\n\n  /**\n   * Load a view safely and remove the last view by calling cleanup, then remove\n   * @param {View} view The View to load\n   */\n  async loadView(view) {\n    try {\n      //console.debug(\"router loadView\");\n      if (view) {\n        const oldView = this._view;\n        if (this.transition && this.transition.in) {\n          //await console.debug(\"have old view\", (oldView) );\n          if (oldView) {\n\n            await Dom.addClass(view.el, \"transition-out\");\n            //await console.debug(\"calling cleanup\");\n            await this.cleanup();\n            //await console.debug(\"Just cleaned up\");\n          }\n          await window.setTimeout(() => {\n            // wait\n            //console.debug(\"waiting...\");\n          }, this.transition.out);\n\n          if (view.render) {\n            await window.setTimeout(() => {\n              // wait\n              //console.debug(\"waiting...\");\n              //console.log(\"el\", view.el);\n              Dom.removeClass(view.el, \"transition-out\");\n              view.render();\n            }, this.transition.in);\n\n          }\n          if (view.delegateEvents) {\n            await view.delegateEvents();\n          }\n\n          this._view = view;\n        } else {\n          if (oldView) {\n            await this.cleanup(oldView);\n          }\n          await view.render();\n          if (view.delegateEvents) {\n            await view.delegateEvents();\n          }\n          this._view = view;\n          //console.debug(\"new view \" + JSON.stringify(this._view));\n        }\n      } else {\n        console.warn(\"No view passed.\");\n      }\n    } catch(e) {\n      console.error(e);\n    }\n    return this;\n  };\n\n  /**\n   * Remove the last view by calling cleanup, then removes\n   */\n  async cleanup(oldView) {\n    //console.debug(`router cleanup view '${(this._view) ? (this._view.name) : \"no view\"}'`);\n    if (oldView || this._view) {\n      //console.debug(`router cleanup view '${(router._view.el) ? (router._view.el) : \"no el\"}'`);\n      const view = (oldView) ? oldView : this._view;\n      if (this.transition && this.transition.out && view.el) {\n\n        //console.debug(\"view transition-out\");\n        const cleanupView = async () => {\n          //if (Dom.containsClass(view.el, \"transition-in\")) {\n          //  await Dom.replaceClass(view.el, \"transition-in\", \"transition-out\");\n          //} else {\n          //  await Dom.addClass(view.el, \"transition-out\");\n          //}\n          if (view.remove) {\n            //await console.debug(`router removing view ${this._view.remove()}`);\n            await view.remove();\n          }\n          //await Dom.removeClass(view.el, \"transition-out\");\n          return view;\n        };\n        await window.setTimeout(cleanupView, this.transition.out);\n        this._view = null;\n      } else {\n        if (this.view.remove) {\n          //console.debug(`router removing view ${this._view.remove()}`);\n          await this.view.remove();\n        }\n        this._view = null;\n      }\n    } else {\n      //console.warn(\"No view to clean up.\");\n    }\n    return this;\n  };\n\n  /**\n   * Initialize is an empty function by default. Override it with your own\n   * initialization logic.\n   */\n  initialize(options) {\n    return super.initialize(options);\n  };\n\n  /**\n   * Manually bind a single named route to a callback.\n   * @param {string} route The route\n   * @param {string} name The function binding name\n   * @param {function} callback binding function\n   * @example\n   * this.route('search/:query/p:num', 'search', (query, num) => {\n   *   ...\n   * });\n   */\n  route(route, name, callback) {\n    if (!_isRegExp(route)) {\n      route = this._routeToRegExp(route);\n    }\n    if (isFunction(name)) {\n      callback = name;\n      name = '';\n    }\n    if (!callback) {\n      callback = this[name];\n    }\n    const router = this;\n\n    this.history.route(route, (fragment) => {\n      const args = router._extractParameters(route, fragment);\n\n      if (router.execute(callback, args, name) !== false) {\n        router.trigger.apply(router, ['route:' + name].concat(args));\n        router.trigger('route', name, args);\n        this.history.trigger('route', router, name, args);\n      }\n    });\n    return this;\n  };\n\n  /**\n   * Execute a route handler with the provided parameters.  This is an\n   * excellent place to do pre-route setup or post-route cleanup.\n   * @param {function} callback binding function\n   * @param {array} args The arges passed\n   */\n  execute(callback, args) {\n    if (callback) {\n      callback.apply(this, args);\n    }\n  };\n\n  /**\n   * Simple proxy to `history` to save a fragment into the history.\n   * @param {string} fragment route fragment\n   * @param {object} options any options to pass\n   */\n  navigate(fragment, options) {\n    this.history.navigate(fragment, options);\n    return { \"routes\": this.routes };\n  };\n\n  /**\n   * Start the history using browser History API\n   * @param {object} options any options to pass\n   */\n  startHistory(options) {\n    if (!this.history.started) {\n      this.history.start(options);\n    }\n    return true;\n  };\n\n  // Bind all defined routes to `history`. We have to reverse the\n  // order of the routes here to support behavior where the most general\n  // routes can be defined at the bottom of the route map.\n  _bindRoutes() {\n    if (!this.routes) {\n      return;\n    }\n    this.routes = result(this, \"routes\");\n    let route,\n        routes = Object.keys(this.routes);\n    while ((route = routes.pop()) != null) {\n      this.route(route, this.routes[route]);\n    }\n  };\n\n  // Convert a route string into a regular expression, suitable for matching\n  // against the current location hash.\n  _routeToRegExp(route) {\n    route = route.replace(escapeRegExp, '\\\\$&')\n                 .replace(optionalParam, '(?:$1)?')\n                 .replace(namedParam, (match, optional) => {\n                   return optional ? match : '([^/?]+)';\n                 })\n                 .replace(splatParam, '([^?]*?)');\n    return new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$');\n  };\n\n  // Given a route, and a URL fragment that it matches, return the array of\n  // extracted decoded parameters. Empty or unmatched parameters will be\n  // treated as `null` to normalize cross-browser behavior.\n  _extractParameters(route, fragment) {\n    let params = route.exec(fragment).slice(1);\n    return _map(params, (param, i) => {\n      // Don't decode the search params.\n      if (i === params.length - 1) {\n        return param || null;\n      }\n      return param ? decodeURIComponent(param) : null;\n    });\n  };\n};\n\nexport default Router;\n","/**\n * Serialize object into query parameters url string\n * @function serialize\n * @memberof Utilities\n * @param {object} obj Object to serialize\n * @returns {string} URL string\n */\nconst serialize = (obj) => {\n  let str = [], p = null;\n  for (p in obj) {\n    if (obj.hasOwnProperty(p)) {\n      str.push(`${encodeURIComponent(p)}=${encodeURIComponent(obj[p])}`);\n    }\n  }\n  return str.join(\"&\");\n};\n\nexport default serialize;\n"],"sourceRoot":""}